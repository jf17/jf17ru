<!DOCTYPE html>
<html lang="ru"><head>
<!-- author: Alexandrovich Alexey Borisovich aka JF17-->
<title> SOLID - jf17.ru</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta http-equiv="Content-Language" content="ru">
<meta name="theme-color" content="#000000"/>
<meta name="Description" content="Author: Alexandrovich Alexey Borisovich aka JF17">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="../../../../../../../assets/main.css">
</head>
<body>
<!-- Heading -->
<header>
<h1><a href="../../../../../../../index.html" >Главная</a></h1>
<h2> <a href="../../../../../../../java/index.html" >Java</a></h2>
<h2> <a href="../../../../../../../java/buzzwords/index.html" >BuzzWords</a></h2>
<hr />
</header>

<!-- Heading -->
<section>
<font color="#ffa31a">	<h2> SOLID</h2></font>
<p>
SOLID  в программировании — мнемонический акроним, введённый Майклом Фэзерсом (Michael Feathers) для первых пяти принципов, названных Робертом Мартином в начале 2000-х, которые означали пять основных принципов объектно-ориентированного программирования и проектирования.
</p>
<font color="#ff0066">Нарушают SOLID принципы:</font><br>
enum<br>
switch<br>
if-else-if<br>
операторы приведения типа<br>
new <br>
</section>
<br><br><br>



<section>
<p>
<h3><span class="contenthead">S – The Single Responsibility Principle </span>(Принцип единственной ответственности) :</h3>
(Должна быть узкая специализация у класса т.е. класс должен отвечать за что-то одно )<br><br>
Определение: Класс должен иметь только одну причину для изменения, т.е. классы должны быть маленького размера. <br>
Краткое описание: <font color="#ffff00">Любой сложный класс должен быть разбит на несколько простых составляющих</font>, отвечающих за определенный аспект поведения, что упрощает как понимание, так и будущее развитие.<br>
Типовые примеры :</p>
<pre class="code"><code>
<span class="codecomment">//Представим класс Order, который обрабатывает заказ и также отвечает за сохранение его в базу данных.</span>
         class <span class="codeclass">Order</span> {
             public void <span class="codemethod">processOrder</span>() {
                <span class="codecomment"> // Логика обработки заказа</span>
             }

             public void <span class="codemethod">saveToDatabase</span>() {
                 <span class="codecomment">// Логика сохранения заказа в базу данных</span>
             }
         }

<span class="codecomment">//Нарушение: Класс выполняет две обязанности — обработку заказа и сохранение его в базу данных.</span>
<span class="codecomment">//Исправление: Разделим ответственность на два класса: Order для обработки заказа и OrderRepository для сохранения.</span>
         class <span class="codeclass">Order</span> {
             public void <span class="codemethod">processOrder</span>() {
                 <span class="codecomment">// Логика обработки заказа</span>
             }
         }

         class <span class="codeclass">OrderRepository</span> {
             public void <span class="codemethod">save</span>(<span class="codeclass">Order</span> <span class="codeobject">order</span>) {
                <span class="codecomment"> // Логика сохранения заказа в базу данных</span>
             }
         }
</code></pre>
<br><br>


<p>
<h3><span class="contenthead">O – The Open-Closed Principle </span>(Принцип открытости/закрытости)</h3>
(Нужно проектировать логику так чтобы её можно было легко расширять не изменяя текущий код)<br><br>
Определение:  Код должен быть открыт для расширения, но закрыт для модификации<br>
Краткое описание: <font color="#ffff00">Использовать интерфейсы и абстрактные классы, которые позволяют подменять реализацию, не трогая базовую структуру программы. </font>. <br>
</p>
<pre class="code"><code>
<span class="codecomment">// Пример  кода без применения OCP:</span>
<span class="codecomment">// (калькулятор который расчитывает скидку для разного типа клиентов)</span>
class <span class="codeclass">DiscountCalculator</span> {
    public double <span class="codemethod">calculateDiscount</span>(String customerType) {
        <span class="codeoperator">if </span>(customerType.equals(<span class="codetext">"Regular"</span>)) {
            return 5.0; <span class="codecomment">// Скидка для обычных клиентов</span>
        } <span class="codeoperator">else if </span>(customerType.equals(<span class="codetext">"VIP"</span>)) {
            return 10.0; <span class="codecomment">// Скидка для VIP-клиентов</span>
        }
        return 0.0;
    }
}
<span class="codecomment">// Проблема: Если в будущем появится новый тип клиента, например, "Premium", нам придется изменять метод calculateDiscount, добавляя новый if или else if блок. </span>

<span class="codecomment">// Исправление: Вместо этого можно создать интерфейс <span class="codeinterface">DiscountPolicy</span> и реализовать его для каждого типа скидок.</span>
interface <span class="codeinterface">DiscountPolicy</span> {
    double <span class="codemethod">calculateDiscount</span>();
}

class <span class="codeclass">RegularCustomerDiscount</span> implements <span class="codeinterface">DiscountPolicy</span> { <span class="codecomment">// для <span class="codetext">"Regular"</span></span>
    public double <span class="codemethod">calculateDiscount</span>() {
        return 5.0;
    }
}

class <span class="codeclass">VIPCustomerDiscount</span> implements <span class="codeinterface">DiscountPolicy</span> { <span class="codecomment">// для <span class="codetext">"VIP"</span></span>
    public double <span class="codemethod">calculateDiscount</span>() {
        return 10.0;
    }
}

class <span class="codeclass">DiscountCalculator</span> { 
    public double <span class="codemethod">calculateDiscount</span>(<span class="codeinterface">DiscountPolicy</span> <span class="codeobject">discountPolicy</span>) {
        return <span class="codeobject">discountPolicy</span><span class="codemethod">.calculateDiscount</span>();
    }
}
<span class="codecomment">// Теперь, чтобы добавить новый тип скидки, мы просто добавляем новый класс, реализующий интерфейс <span class="codeinterface">DiscountPolicy</span>, не изменяя основной код <span class="codeclass">DiscountCalculator.</span></span>
</code></pre>
<br>


<p>
<h3><span class="contenthead">L – The Liskov Substitution Principle</span></h3>

Название: Принцип замещения Барбары Лисков<br>

Определение: Должна быть возможность вместо базового типа подставить любой его подтип.<br>

Смысл: <font color="#ffff00">При наследовании мы не должны изменять(вмешиваться) поведение нашего "родителя класса" (лучше использовать интерфейс в качестве родителя)</font>. Реализуйте наследование подтипов правильно.<br>

Краткое описание: для корректной реализации отношения «ЯВЛЯЕТСЯ», наследник может ослаблять предусловие и усиливать постусловие (требовать меньше и гарантировать больше), при этом инварианты базового класса должны выполняться наследником. При нарушении этих правил подстановка экземпляров наследника в метод, принимающий базовый класс будет приводить к непредсказуемым последствиям.<br>

Типичные примеры нарушения: несогласованное поведение наследников, что приводит к необходимости приводить экземпляры базового класса к конкретным типам наследников.<br>

Anti-LSP – Принцип непонятного наследования. Данный анти-принцип проявляется либо в чрезмерном количестве наследования, либо в его полном отсутствии, в зависимости от опыта и взглядов местного главного архитектора <br>
<br>
</p>

<p>
<h3><span class="contenthead">I – Interface Segregation Principle</span></h3>

Название: Принцип разделения интерфейсов<br>

Определение: клиенты не должны вынужденно зависеть от методов, которыми не пользуются.<br>

Смысл: класс должен предоставлять удобный интерфейс с точки зрения его разнообразных клиентов.<br>

Краткое описание: <font color="#ffff00">В интерфейсе не должно быть методов которые не будут использовать его наследники !! Если есть такой интерфейс , то его надо разбить на два интерфейса!!</font>.  Интерфейс класса должен быть цельным и согласованным не зависимо от числа клиентов. Несколько разных клиентов вполне могут использовать лишь подмножество методов класса, до тех пор, пока интерфейс класса будет оставаться согласованным. Проблемы появляются тогда, когда интерфейс класса начинает распухать или появляются разные методы с похожей семантикой лишь для того, чтобы ими было удобно пользоваться определенным клиентам.<br>

Типичные примеры нарушения: 1) класс или интерфейс содержит несколько методов со схожей семантикой, которые используются разными клиентами; 2) интерфейс класса слишком разнороден и содержит методы, отвечающие за слабосвязанные операции.<br>

Anti-ISP – Принцип тысячи интерфейсов. Интерфейсы классов разбиваются на слишком большое число составляющих, что делает их неудобными для использования всеми клиентами. <br>
<br>
</p>

<p>
<h3><span class="contenthead">D – The Dependency Inversion Principle</span></h3>

Название: Принцип инверсии зависимостей<br>

Определение: Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те и другие должны зависеть от абстракций.<br>

Смысл: сделать ключевые и/или изменчивые зависимости класса явными.<br>

Краткое описание: <font color="#ffff00">Между слоями(например бизнес логикой и базой данных) желательно использовать интерфейс вместо класса</font>. Слишком большое число зависимостей класса говорит о проблемах в дизайне. Возможно класс делает слишком многое, или же текущий класс не удачен, что приводит к необходимости дергания по одному методу у слишком большого числа зависимостей. Любой объектный дизайн представляет собой некоторый граф взаимодействующих объектов, при этом некоторые зависимости являются частью реализации и должны создаваться напрямую (композиция), а некоторые – передаваться ему извне (агрегация). Выделять зависимости особенно полезно, когда они являются изменчивыми (завязаны на окружения), или же представляют собой некоторую форму «стратегий».<br>

Типичные примеры нарушения: использование синглтонов, сервис-локаторов или же создание ключевых зависимостей класса по ходу дела в закрытых методах.<br>

Anti-DIP – Принцип инверсии сознания или DI-головного мозга. Интерфейсы выделяются для каждого класса и пачками передаются через конструкторы. Понять, где находится логика становится практически невозможно. <br>
<br><br>
</p>

</section>


<footer>
<!-- работа с куки -->
<script type="text/javascript">
	var x = document.cookie;
	if(x=='size=150'){
	document.body.style.fontSize='150%';
	}
	</script>
</footer>
</body><!-- Footer --></html>