<!DOCTYPE html>
<html lang="ru"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<!-- author: Aleksandrovich Aleksey Borisovich -->
<title> Многопоточность в Java - jf17.ru</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="https://jf17.ru/assets/main.css"> 
</head>
<body>
<!-- Heading -->
<section>
<div class="content">
<h1> <a href="https://jf17.ru/" >Главная</a></h1>
<h2> <a href="https://jf17.ru/java/index.html" >Java</a></h2>
<hr />
</section>
                                

<section>
<div class="content">
<font color="#ffa31a">	<h2> Чем отличается процесс от потока?</h2></font>
<p>
Процесс это некоторая единица операционной системы, которой выделена память и другие ресурсы. Поток это единица исполнения кода. Поток имеет стэк - некоторую свою память для исполнения. Остальная память процесса - общая для всех его потоков. Потоки исполняются на ядрах процессора.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> Каким образом можно создать поток?</h2></font>
<p>
Есть несколько способов создания и запуска потоков:
</p>
<ul>
<li><span class="table-head">С помощью класса, реализующего Runnable:</span></li>
<ul>
<li>Создать объект класса Thread.</li>
<li>Создать объект класса, реализующего интерфейс Runnable.</li>
<li>Вызвать у созданного объекта Thread метод start() (после этого запустится метод run() у переданного объекта, реализующего Runnable).</li>
</ul>
<li><span class="table-head">С помощью класса, расширяющего Thread:</span></li>
<ul>
<li>Создать объект класса ClassName extends Thread.</li>
<li>Переопределить run() в этом классе (смотрите примере ниже, где передается имя потока 'Second').</li>
</ul>
<li><span class="table-head">С помощью класса, реализующего java.util.concurrent.Callable:</span></li>
<ul>
<li>Создать объект класса, реализующего интерфейс Callable.</li>
<li>Создать объект ExecutorService с указанием пула потоков.</li>
<li>Создать объект Future. Запуск происходит через метод submit(); Сигнатура: &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task).</li>
</ul>
</ul>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Что такое монитор? </h2></font>
<p>
Контроль за доступом к объекту-ресурсу обеспечивает понятие монитора. Монитор экземпляра может иметь только одного владельца. При попытке конкурирующего доступа к объекту, чей монитор имеет владельца, желающий заблокировать объект-ресурс поток должен подождать освобождения монитора этого объекта и только после этого завладеть им и начать использование объекта-ресурса.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> Какие способы синхронизации в Java? </h2></font>
<ul>
<li>
<p>
Поток, который ждет выполнения каких-либо условий, вызывает у этого объекта метод wait, предварительно захватив его монитор. На этом его работа приостанавливается. Другой поток может вызвать на этом же самом объекте метод notify (опять же, предварительно захватив монитор объекта), в результате чего, ждущий на объекте поток "просыпается" и продолжает свое выполнение.&nbsp;
</p></li><li>
<p>
Метод join, вызванный у экземпляра класса Thread, позволяет текущему потоку остановиться до того момента, как поток, связаный с этим экземпляром, закончит работу.&nbsp;
</p></li><li>
<p>
который предоставляет набор классов для организации межпоточного взаимодействия. Примеры таких классов - Lock, семафор (Semaphore), etc. Концепция данного подхода заключается в использовании атомарных операций и переменных.
</p></li>
</ul>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Как работают методы wait и notify/notifyAll?</h2></font>
<p>
Эти метеоды предназначены для межпоточной синхронизации, для взаимодействия потоков между собой.<br>
Как работают эти методы. Во-первых они могут вызваны только потоком, который захватил монитор объекта, для которого эти методы вызываются. То есть они вызываются внутри блока synchronized и для объекта, монитор которого этим synchronized захвачен. Если внутри synchronized метода - то для класса, к которому относятся эти методы.<br>
Что делает метод wait(). Метод wait() отдает (освобождает) монитор объекта, так что другие потоки теперь могут его (монитор) захватить, то есть войти в блок synchronized для этого объекта. Затем метод wait() переходит в состояние ожидания, до тех пор пока другой поток не вызывет метод notify() или notifyAll() для этого же объекта. После чего поток, в котором был вызван wait(), пытается снова захватить монитор объекта и когда монитор становится свободным, то есть когда другой поток освобождает его, захватывает монитор и продолжает выполнение со следующего после wait() оператора. Причем у потока вызвашего wait() нет никакого преимущества перед другими потоками, ожидающими захвата того же монитора.<br>
Что делают методы notify(), notifyAll(). Они "пробуждают" поток, ожидающий методом wait() (если такой есть), и переводят его в состояние ожидания освобождения монитора. Разница между notify() и notifyAll() в том, что notify() пробуждает только один поток , ожидающий методом wait(), какой именно будет пробужден - определить нельзя, а notifyAll() - все такие потоки.<br>
</p>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Чем отличается работа метода wait с параметром и без параметра?</h2></font>
<ul>
<li>
final void wait() &nbsp;- метод используется в многопоточной среде, может вызываться только потоком, владеющим объектом синхронизации. При этом объект синхронизации освобождается, а текущий поток переходит в режим ожидания сигнала освобождения объекта синхронизации другим потоком путем вызова метода notify() либо notifyAll().
</li>
<li>
final void wait(long time) &nbsp;- аналогично wait() данный метод используется в многопоточной среде, переходит текущий поток в режим ожидания сигнала освобождения объекта синхронизации другим потоком путем вызова метода notify() либо notifyAll(), или ожидание происходит заданное время time, затем выполнение продолжается безусловно.
</li>
</ul>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Как работает метод Thread.yield()? Чем отличаются методы Thread.sleep() и Thread.yield()?</h2></font>
<ul>
<li>
метод&nbsp;yield() - пытается сказать планировщику потоков, что нужно выполнить другой поток, что ожидает в очереди на выполнение. Метод не пытается перевести текущий поток в состояние блокировки, сна или ожидания. Он просто пытается его перевести из состояние "работающий" в состояние "работоспособный". Однако выполнение метода может вообще не произвести никакого эффекта. состояние потока остатается RUNNABLE&nbsp;
</li>
<li>
метод sleep() - приостанавливает поток на указанное. состояние меняется на TIMED_WAITING, по истечению - RUNNABLE
</li>
<li>
может быть вызвано только у объекта владеющего блокировкой, в противном случае выкинется исключение IllegalMonitorStateException. при срабатывании метода блокировка отпускается, что позволяет продолжить работу другим потокам ожидающим захватить ту же самую блокировку . в случае wait(int) с аргументом состояние будет TIMED_WAITING.
</li>
</ul>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Как работает метод Thread.join() ?</h2></font>
<p>
Метод join() вызывается для того, чтобы привязать текущий поток в конец потока для которого вызывается метод. То есть второй поток будет в режиме блокировки пока первый поток не выполнится.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> Что такое dead lock ?</h2></font>
<p>
Это когда один поток А получил блокировку на объект А1, а поток В получил блокировку на объект В1. В то время как поток А пытается получит блокировку на объект В1, а поток В на А1.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> На каком объекте происходит синхронизация при вызове static synchronized метода ?</h2></font>
<p>
Представьте себе ситуацию что два потока одновременно изменяют состояние какого-то объекта, это недопустимо. Для этого необходимо синхронизировать потоки. Как это сделать? Ключевое слово synchronized позволяет это сделать установив в сигнатуре метода. Или же в методе можно описать блок synchronized, только в качестве параметра необходимо передать объект, который будет блокироватся.<br>
Статические синхронизированные методы и нестатические &nbsp;синхронизированные методы не будет &nbsp;блокировать друг друга, никогда. Статические &nbsp;методы блокируются на экземпляре класса Class в то время как нестатические методы блокируются на текущем экземпляре (this). Эти действия не мешают друг другу.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> Для чего используется ключевое слово volatile, synchronized, transient, native ?</h2></font>
<ul>
<li>
volatile - указывает на то, что поле синхронизировано для нескольких потоков .
</li>
<li>
synchronized - указывает на то что метод синхронизированный или же в методе может находится такой блок синхронизации.
</li>
<li>
transient - указывает на то, что переменная не подлежит сериализации .
</li>
<li>
native - говорит о том, что реализация метода написана на другой программной платформе .
</li>
</ul>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Что значит приоритет потока?</h2></font>
<p>
Приоритет потока - это число от 1 до 10, в зависимости от которого, планировщик потоков выбирает какой поток запускать. Однако полагаться на приоритеты для предсказуемого выполнения многопоточной &nbsp;программы нельзя!
</p>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Что такое потоки - демоны в джава?</h2></font>
<p>
Это потоки, которое работают в фоновом режиме и не гарантируют что они завершатся. Тоеть если все потоки завершились, то поток демон просто обрывается вместе с закрытием приложения.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> Что значит усыпить поток?</h2></font>
<p>
Перевести поток в спящее состояние можно с помощью метода sleep(long ms) ms - время в миллисекундах.<br>
При вызове этого метода, поток переходит в спящее состояние, после сна, поток переходит в пул потоков и находится в состоянии "работоспособный", т.е. не гарантируется что после пробуждения он будет сразу выполняться. Также поток не может усыпить другой поток, так как метод sleep - это статический метод! Вы просто усыпите текущий поток и не более того! Также метод sleep() может возбуждать InterruptedException().
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> В каких состояниях может быть поток в джава? Как вообще работает поток?</h2></font>
<p>
У нас есть текущий поток, в котором выполняется метод main. Этот поток имеет свой стек и этот стек начинается с вызова метода main.<br>
Далее в методе main мы создаем новый поток, что происходит… создается новый поток и для него выделяется свой стек с первоначальным методом run().<br>
Когда мы запускаем несколько потоков, то мы не можем гарантировать определенный порядок их вызовов. Планированием потоков занимается планировщик потоков JVM, выбирая из пулов потоков поток. Мы даже не можем гарантировать что если первый поток начался выполнятся первым, то он и закончит выполнятся первым, он может закончить выполнятся последним.<br>
Еще такой ньюанс, что поток, который закончил свое выполнение, не может быть повторно запущен! Он находится в состоянии "мертвый", а для запуска потока нового потока, объект должен находится в состоянии "новый".
</p>
<ul>
Потоки имеют такие состояния:
<li>
Новый (это когда только создали экземпляр класса Thread) .
</li>
<li>
Живой или работоспособный(переходит в это состояние после запуска метода start(), но это не означает что поток уже работает! Или же он может перейти в это состояние из состояние работающий или блокированный) .
</li>
<li>
Работающий (это когда метод run() начал выполнятся) .
</li>
<li>
Ожидающий (waiting)/Заблокированный (blocked)/Спящий(sleeping). Эти состояния характеризуют поток как не готовый к работе. Я объединил эти состояния т.к. все они имеют общую черту – поток еще жив (alive), но в настоящее время не может быть выполнен.Другими словами поток уже не работает, но он может вернутся в рабочее состояние.Поток может быть заблокирован, это может &nbsp;означать что он ждет освобождение каких-то ресурсов. Поток может спать, если встретился метод sleep(long s) , или же он может ожидать, если встретился метод wait(), он будет ждать пока не вызовится метод notify() или notifyall().
</li>
<li>
Мертвый(состояние когда метод run() завершил свою работу) .
</li>
</ul>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> Чем отличаются два интерфейса для реализации задач Runnable и Callable ?</h2></font>
<ul>
<li>
Интерфейс Runnable появиля в Java 1.0, а интерфейс Callable был введен в Java 5.0 в составе библиотеки java.util.concurrent.
</li>
<li>
Классы, реализующие интерфейс Runnable должны реализовывать метод run() для выполнения задачи. Классы, реализующие интерфейс Callable должны реализовывать метод call() для выполнения задачи.
</li>
<li>
Метод Runnable.run() не возвращает никакого значения, его тип void, а метод Callable.call() может возвращать значение типа T. Интерфейс Callable является параметризированным Callable&lt;T&gt; и тип значения, которое будет возвращаться в методе call() задается этим параметром T.
</li>
<li>
Метод run() не может бросить проверяемое исключение, в то время как метод call() может бросить проверяемое исключение.
</li>
</ul>
</div>
</section>

<section>
<!-- Полезные ссылки . -->
<div class="contentname">
<h4>Полезные ссылки:</h4>
</div>
<div class="content">
<ul>
<li> <a href="xxxxxx" target="_blank">xxxxx</a></li>

</ul></div>
</section>



<footer>
<!-- работа с куки -->
<script type="text/javascript">
	var x = document.cookie;
	if(x=='size=150'){
	document.body.style.fontSize='150%';
	}
	</script>
</footer>
</div>
</div></section></div></body><!-- Footer --></html>