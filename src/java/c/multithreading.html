<!DOCTYPE html>
<html lang="ru"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<!-- author: Aleksandrovich Aleksey Borisovich -->
<title> Многопоточность в Java - jf17.ru</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="https://jf17.ru/assets/main.css"> 
</head>
<body>
<!-- Heading -->
<section>
<div class="content">
<h1> <a href="https://jf17.ru/" >Главная</a></h1>
<h2> <a href="https://jf17.ru/java/index.html" >Java</a></h2>
<hr />
</section>
                                

<section>
<div class="content">
<font color="#ffa31a">	<h2> Чем отличается процесс от потока?</h2></font>
<p>
Процесс это некоторая единица операционной системы, которой выделена память и другие ресурсы. Поток это единица исполнения кода. Поток имеет стэк - некоторую свою память для исполнения. Остальная память процесса - общая для всех его потоков. Потоки исполняются на ядрах процессора.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> Каким образом можно создать поток?</h2></font>
<p>
Есть несколько способов создания и запуска потоков:
</p>
<ul>
<li><span class="table-head">С помощью класса, реализующего Runnable:</span></li>
<ul>
<li>Создать объект класса Thread.</li>
<li>Создать объект класса, реализующего интерфейс Runnable.</li>
<li>Вызвать у созданного объекта Thread метод start() (после этого запустится метод run() у переданного объекта, реализующего Runnable).</li>
</ul>
<li><span class="table-head">С помощью класса, расширяющего Thread:</span></li>
<ul>
<li>Создать объект класса ClassName extends Thread.</li>
<li>Переопределить run() в этом классе (смотрите примере ниже, где передается имя потока 'Second').</li>
</ul>
<li><span class="table-head">С помощью класса, реализующего java.util.concurrent.Callable:</span></li>
<ul>
<li>Создать объект класса, реализующего интерфейс Callable.</li>
<li>Создать объект ExecutorService с указанием пула потоков.</li>
<li>Создать объект Future. Запуск происходит через метод submit(); Сигнатура: &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task).</li>
</ul>
</ul>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Что такое монитор? </h2></font>
<p>
Контроль за доступом к объекту-ресурсу обеспечивает понятие монитора. Монитор экземпляра может иметь только одного владельца. При попытке конкурирующего доступа к объекту, чей монитор имеет владельца, желающий заблокировать объект-ресурс поток должен подождать освобождения монитора этого объекта и только после этого завладеть им и начать использование объекта-ресурса.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> Какие способы синхронизации в Java? </h2></font>
<ul>
<li>
<p>
Поток, который ждет выполнения каких-либо условий, вызывает у этого объекта метод wait, предварительно захватив его монитор. На этом его работа приостанавливается. Другой поток может вызвать на этом же самом объекте метод notify (опять же, предварительно захватив монитор объекта), в результате чего, ждущий на объекте поток "просыпается" и продолжает свое выполнение.&nbsp;
</p></li><li>
<p>
Метод join, вызванный у экземпляра класса Thread, позволяет текущему потоку остановиться до того момента, как поток, связаный с этим экземпляром, закончит работу.&nbsp;
</p></li><li>
<p>
который предоставляет набор классов для организации межпоточного взаимодействия. Примеры таких классов - Lock, семафор (Semaphore), etc. Концепция данного подхода заключается в использовании атомарных операций и переменных.
</p></li>
</ul>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Как работают методы wait и notify/notifyAll?</h2></font>
<p>
Эти метеоды предназначены для межпоточной синхронизации, для взаимодействия потоков между собой.<br>
Как работают эти методы. Во-первых они могут вызваны только потоком, который захватил монитор объекта, для которого эти методы вызываются. То есть они вызываются внутри блока synchronized и для объекта, монитор которого этим synchronized захвачен. Если внутри synchronized метода - то для класса, к которому относятся эти методы.<br>
Что делает метод wait(). Метод wait() отдает (освобождает) монитор объекта, так что другие потоки теперь могут его (монитор) захватить, то есть войти в блок synchronized для этого объекта. Затем метод wait() переходит в состояние ожидания, до тех пор пока другой поток не вызывет метод notify() или notifyAll() для этого же объекта. После чего поток, в котором был вызван wait(), пытается снова захватить монитор объекта и когда монитор становится свободным, то есть когда другой поток освобождает его, захватывает монитор и продолжает выполнение со следующего после wait() оператора. Причем у потока вызвашего wait() нет никакого преимущества перед другими потоками, ожидающими захвата того же монитора.<br>
Что делают методы notify(), notifyAll(). Они "пробуждают" поток, ожидающий методом wait() (если такой есть), и переводят его в состояние ожидания освобождения монитора. Разница между notify() и notifyAll() в том, что notify() пробуждает только один поток , ожидающий методом wait(), какой именно будет пробужден - определить нельзя, а notifyAll() - все такие потоки.<br>
</p>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Чем отличается работа метода wait с параметром и без параметра?</h2></font>
<ul>
<li>
final void wait() &nbsp;- метод используется в многопоточной среде, может вызываться только потоком, владеющим объектом синхронизации. При этом объект синхронизации освобождается, а текущий поток переходит в режим ожидания сигнала освобождения объекта синхронизации другим потоком путем вызова метода notify() либо notifyAll().
</li>
<li>
final void wait(long time) &nbsp;- аналогично wait() данный метод используется в многопоточной среде, переходит текущий поток в режим ожидания сигнала освобождения объекта синхронизации другим потоком путем вызова метода notify() либо notifyAll(), или ожидание происходит заданное время time, затем выполнение продолжается безусловно.
</li>
</ul>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Как работает метод Thread.yield()? Чем отличаются методы Thread.sleep() и Thread.yield()?</h2></font>
<ul>
<li>
метод&nbsp;yield() - пытается сказать планировщику потоков, что нужно выполнить другой поток, что ожидает в очереди на выполнение. Метод не пытается перевести текущий поток в состояние блокировки, сна или ожидания. Он просто пытается его перевести из состояние "работающий" в состояние "работоспособный". Однако выполнение метода может вообще не произвести никакого эффекта. состояние потока остатается RUNNABLE&nbsp;
</li>
<li>
метод sleep() - приостанавливает поток на указанное. состояние меняется на TIMED_WAITING, по истечению - RUNNABLE
</li>
<li>
может быть вызвано только у объекта владеющего блокировкой, в противном случае выкинется исключение IllegalMonitorStateException. при срабатывании метода блокировка отпускается, что позволяет продолжить работу другим потокам ожидающим захватить ту же самую блокировку . в случае wait(int) с аргументом состояние будет TIMED_WAITING.
</li>
</ul>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Как работает метод Thread.join() ?</h2></font>
<p>
Метод join() вызывается для того, чтобы привязать текущий поток в конец потока для которого вызывается метод. То есть второй поток будет в режиме блокировки пока первый поток не выполнится.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> Что такое dead lock ?</h2></font>
<p>
Это когда один поток А получил блокировку на объект А1, а поток В получил блокировку на объект В1. В то время как поток А пытается получит блокировку на объект В1, а поток В на А1.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> На каком объекте происходит синхронизация при вызове static synchronized метода ?</h2></font>
<p>
Представьте себе ситуацию что два потока одновременно изменяют состояние какого-то объекта, это недопустимо. Для этого необходимо синхронизировать потоки. Как это сделать? Ключевое слово synchronized позволяет это сделать установив в сигнатуре метода. Или же в методе можно описать блок synchronized, только в качестве параметра необходимо передать объект, который будет блокироватся.<br>
Статические синхронизированные методы и нестатические &nbsp;синхронизированные методы не будет &nbsp;блокировать друг друга, никогда. Статические &nbsp;методы блокируются на экземпляре класса Class в то время как нестатические методы блокируются на текущем экземпляре (this). Эти действия не мешают друг другу.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> Для чего используется ключевое слово volatile, synchronized, transient, native ?</h2></font>
<ul>
<li>
volatile - указывает на то, что поле синхронизировано для нескольких потоков .
</li>
<li>
synchronized - указывает на то что метод синхронизированный или же в методе может находится такой блок синхронизации.
</li>
<li>
transient - указывает на то, что переменная не подлежит сериализации .
</li>
<li>
native - говорит о том, что реализация метода написана на другой программной платформе .
</li>
</ul>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Что значит приоритет потока?</h2></font>
<p>
Приоритет потока - это число от 1 до 10, в зависимости от которого, планировщик потоков выбирает какой поток запускать. Однако полагаться на приоритеты для предсказуемого выполнения многопоточной &nbsp;программы нельзя!
</p>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Что такое потоки - демоны в джава?</h2></font>
<p>
Это потоки, которое работают в фоновом режиме и не гарантируют что они завершатся. Тоеть если все потоки завершились, то поток демон просто обрывается вместе с закрытием приложения.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> Что значит усыпить поток?</h2></font>
<p>
Перевести поток в спящее состояние можно с помощью метода sleep(long ms) ms - время в миллисекундах.<br>
При вызове этого метода, поток переходит в спящее состояние, после сна, поток переходит в пул потоков и находится в состоянии "работоспособный", т.е. не гарантируется что после пробуждения он будет сразу выполняться. Также поток не может усыпить другой поток, так как метод sleep - это статический метод! Вы просто усыпите текущий поток и не более того! Также метод sleep() может возбуждать InterruptedException().
</p>
</div>
</section>





<section>
<!-- Полезные ссылки . -->
<div class="contentname">
<h4>Полезные ссылки:</h4>
</div>
<div class="content">
<ul>
<li> <a href="xxxxxx" target="_blank">xxxxx</a></li>

</ul></div>
</section>



<footer>
<!-- работа с куки -->
<script type="text/javascript">
	var x = document.cookie;
	if(x=='size=150'){
	document.body.style.fontSize='150%';
	}
	</script>
</footer>
</div>
</div></section></div></body><!-- Footer --></html>