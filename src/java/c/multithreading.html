<!DOCTYPE html>
<html lang="ru"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<!-- author: Aleksandrovich Aleksey Borisovich -->
<title> Многопоточность в Java - jf17.ru</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="https://jf17.ru/assets/main.css"> 
</head>
<body>
<!-- Heading -->
<section>
<div class="content">
<h1> <a href="https://jf17.ru/" >Главная</a></h1>
<h2> <a href="https://jf17.ru/java/index.html" >Java</a></h2>
<hr />
</section>
                                

<section>
<div class="content">
<font color="#ffa31a">	<h2> Чем отличается процесс от потока?</h2></font>
<p>
Процесс это некоторая единица операционной системы, которой выделена память и другие ресурсы. Поток это единица исполнения кода. Поток имеет стэк - некоторую свою память для исполнения. Остальная память процесса - общая для всех его потоков. Потоки исполняются на ядрах процессора.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> Каким образом можно создать поток?</h2></font>
<p>
Есть несколько способов создания и запуска потоков:
</p>
<ul>
<li><span class="table-head">С помощью класса, реализующего Runnable :</span></li>
<ul>
<li>Создать объект класса Thread.</li>
<li>Создать объект класса, реализующего интерфейс Runnable.</li>
<li>Вызвать у созданного объекта Thread метод start() (после этого запустится метод run() у переданного объекта, реализующего Runnable).</li>
</ul>
<li><span class="table-head">С помощью класса, расширяющего Thread : </span></li>
<ul>
<li>Создать объект класса ClassName extends Thread.</li>
<li>Переопределить run() в этом классе (смотрите примере ниже, где передается имя потока 'Second').</li>
</ul>
<li><span class="table-head">С помощью класса, реализующего java.util.concurrent.Callable :</span></li>
<ul>
<li>Создать объект класса, реализующего интерфейс Callable.</li>
<li>Создать объект ExecutorService с указанием пула потоков.</li>
<li>Создать объект Future. Запуск происходит через метод submit(); Сигнатура: &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task).</li>
</ul>
</ul>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Что такое монитор? </h2></font>
<p>
Контроль за доступом к объекту-ресурсу обеспечивает понятие монитора. Монитор экземпляра может иметь только одного владельца. При попытке конкурирующего доступа к объекту, чей монитор имеет владельца, желающий заблокировать объект-ресурс поток должен подождать освобождения монитора этого объекта и только после этого завладеть им и начать использование объекта-ресурса.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> Какие способы синхронизации в Java? </h2></font>
<ul>
<li>
<p>
Поток, который ждет выполнения каких-либо условий, вызывает у этого объекта метод wait, предварительно захватив его монитор. На этом его работа приостанавливается. Другой поток может вызвать на этом же самом объекте метод notify (опять же, предварительно захватив монитор объекта), в результате чего, ждущий на объекте поток "просыпается" и продолжает свое выполнение.&nbsp;
</p></li><li>
<p>
Метод join, вызванный у экземпляра класса Thread, позволяет текущему потоку остановиться до того момента, как поток, связаный с этим экземпляром, закончит работу.&nbsp;
</p></li><li>
<p>
который предоставляет набор классов для организации межпоточного взаимодействия. Примеры таких классов - Lock, семафор (Semaphore), etc. Концепция данного подхода заключается в использовании атомарных операций и переменных.
</p></li>
</ul>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Как работают методы wait и notify/notifyAll?</h2></font>
<p>
Эти метеоды предназначены для межпоточной синхронизации, для взаимодействия потоков между собой.<br>
Как работают эти методы. Во-первых они могут вызваны только потоком, который захватил монитор объекта, для которого эти методы вызываются. То есть они вызываются внутри блока synchronized и для объекта, монитор которого этим synchronized захвачен. Если внутри synchronized метода - то для класса, к которому относятся эти методы.<br>
Что делает метод wait(). Метод wait() отдает (освобождает) монитор объекта, так что другие потоки теперь могут его (монитор) захватить, то есть войти в блок synchronized для этого объекта. Затем метод wait() переходит в состояние ожидания, до тех пор пока другой поток не вызывет метод notify() или notifyAll() для этого же объекта. После чего поток, в котором был вызван wait(), пытается снова захватить монитор объекта и когда монитор становится свободным, то есть когда другой поток освобождает его, захватывает монитор и продолжает выполнение со следующего после wait() оператора. Причем у потока вызвашего wait() нет никакого преимущества перед другими потоками, ожидающими захвата того же монитора.<br>
Что делают методы notify(), notifyAll(). Они "пробуждают" поток, ожидающий методом wait() (если такой есть), и переводят его в состояние ожидания освобождения монитора. Разница между notify() и notifyAll() в том, что notify() пробуждает только один поток , ожидающий методом wait(), какой именно будет пробужден - определить нельзя, а notifyAll() - все такие потоки.<br>
</p>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Чем отличается работа метода wait с параметром и без параметра?</h2></font>
<ul>
<li>
final void wait() - метод используется в многопоточной среде, может вызываться только потоком, владеющим объектом синхронизации. При этом объект синхронизации освобождается, а текущий поток переходит в режим ожидания сигнала освобождения объекта синхронизации другим потоком путем вызова метода notify() либо notifyAll().
</li>
<li>
final void wait(long time) - аналогично wait() данный метод используется в многопоточной среде, переходит текущий поток в режим ожидания сигнала освобождения объекта синхронизации другим потоком путем вызова метода notify() либо notifyAll(), или ожидание происходит заданное время time, затем выполнение продолжается безусловно.
</li>
</ul>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Как работает метод Thread.yield()? Чем отличаются методы Thread.sleep() и Thread.yield()?</h2></font>
<ul>
<li>
метод&nbsp;yield() - пытается сказать планировщику потоков, что нужно выполнить другой поток, что ожидает в очереди на выполнение. Метод не пытается перевести текущий поток в состояние блокировки, сна или ожидания. Он просто пытается его перевести из состояние "работающий" в состояние "работоспособный". Однако выполнение метода может вообще не произвести никакого эффекта. состояние потока остатается RUNNABLE&nbsp;
</li>
<li>
метод sleep() - приостанавливает поток на указанное. состояние меняется на TIMED_WAITING, по истечению - RUNNABLE
</li>
<li>
может быть вызвано только у объекта владеющего блокировкой, в противном случае выкинется исключение IllegalMonitorStateException. при срабатывании метода блокировка отпускается, что позволяет продолжить работу другим потокам ожидающим захватить ту же самую блокировку . в случае wait(int) с аргументом состояние будет TIMED_WAITING.
</li>
</ul>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Как работает метод Thread.join() ?</h2></font>
<p>
Метод join() вызывается для того, чтобы привязать текущий поток в конец потока для которого вызывается метод. То есть второй поток будет в режиме блокировки пока первый поток не выполнится.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> Что такое dead lock ?</h2></font>
<p>
Это когда один поток А получил блокировку на объект А1, а поток В получил блокировку на объект В1. В то время как поток А пытается получит блокировку на объект В1, а поток В на А1.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> На каком объекте происходит синхронизация при вызове static synchronized метода ?</h2></font>
<p>
Представьте себе ситуацию что два потока одновременно изменяют состояние какого-то объекта, это недопустимо. Для этого необходимо синхронизировать потоки. Как это сделать? Ключевое слово synchronized позволяет это сделать установив в сигнатуре метода. Или же в методе можно описать блок synchronized, только в качестве параметра необходимо передать объект, который будет блокироватся.<br>
Статические синхронизированные методы и нестатические &nbsp;синхронизированные методы не будет &nbsp;блокировать друг друга, никогда. Статические &nbsp;методы блокируются на экземпляре класса Class в то время как нестатические методы блокируются на текущем экземпляре (this). Эти действия не мешают друг другу.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> Для чего используется ключевое слово volatile, synchronized, transient, native ?</h2></font>
<ul>
<li>
volatile - указывает на то, что поле синхронизировано для нескольких потоков .
</li>
<li>
synchronized - указывает на то что метод синхронизированный или же в методе может находится такой блок синхронизации.
</li>
<li>
transient - указывает на то, что переменная не подлежит сериализации .
</li>
<li>
native - говорит о том, что реализация метода написана на другой программной платформе .
</li>
</ul>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Что значит приоритет потока?</h2></font>
<p>
Приоритет потока - это число от 1 до 10, в зависимости от которого, планировщик потоков выбирает какой поток запускать. Однако полагаться на приоритеты для предсказуемого выполнения многопоточной &nbsp;программы нельзя!
</p>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Что такое потоки - демоны в джава?</h2></font>
<p>
Это потоки, которое работают в фоновом режиме и не гарантируют что они завершатся. Тоеть если все потоки завершились, то поток демон просто обрывается вместе с закрытием приложения.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> Что значит усыпить поток?</h2></font>
<p>
Перевести поток в спящее состояние можно с помощью метода sleep(long ms) ms - время в миллисекундах.<br>
При вызове этого метода, поток переходит в спящее состояние, после сна, поток переходит в пул потоков и находится в состоянии "работоспособный", т.е. не гарантируется что после пробуждения он будет сразу выполняться. Также поток не может усыпить другой поток, так как метод sleep - это статический метод! Вы просто усыпите текущий поток и не более того! Также метод sleep() может возбуждать InterruptedException().
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> В каких состояниях может быть поток в джава? Как вообще работает поток?</h2></font>
<p>
У нас есть текущий поток, в котором выполняется метод main. Этот поток имеет свой стек и этот стек начинается с вызова метода main.<br>
Далее в методе main мы создаем новый поток, что происходит… создается новый поток и для него выделяется свой стек с первоначальным методом run().<br>
Когда мы запускаем несколько потоков, то мы не можем гарантировать определенный порядок их вызовов. Планированием потоков занимается планировщик потоков JVM, выбирая из пулов потоков поток. Мы даже не можем гарантировать что если первый поток начался выполнятся первым, то он и закончит выполнятся первым, он может закончить выполнятся последним.<br>
Еще такой ньюанс, что поток, который закончил свое выполнение, не может быть повторно запущен! Он находится в состоянии "мертвый", а для запуска потока нового потока, объект должен находится в состоянии "новый".
</p>
<ul>
Потоки имеют такие состояния:
<li>
Новый (это когда только создали экземпляр класса Thread) .
</li>
<li>
Живой или работоспособный(переходит в это состояние после запуска метода start(), но это не означает что поток уже работает! Или же он может перейти в это состояние из состояние работающий или блокированный) .
</li>
<li>
Работающий (это когда метод run() начал выполнятся) .
</li>
<li>
Ожидающий (waiting)/Заблокированный (blocked)/Спящий(sleeping). Эти состояния характеризуют поток как не готовый к работе. Я объединил эти состояния т.к. все они имеют общую черту – поток еще жив (alive), но в настоящее время не может быть выполнен.Другими словами поток уже не работает, но он может вернутся в рабочее состояние.Поток может быть заблокирован, это может &nbsp;означать что он ждет освобождение каких-то ресурсов. Поток может спать, если встретился метод sleep(long s) , или же он может ожидать, если встретился метод wait(), он будет ждать пока не вызовится метод notify() или notifyall().
</li>
<li>
Мертвый(состояние когда метод run() завершил свою работу) .
</li>
</ul>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> Чем отличаются два интерфейса для реализации задач Runnable и Callable ?</h2></font>
<ul>
<li>
Интерфейс Runnable появиля в Java 1.0, а интерфейс Callable был введен в Java 5.0 в составе библиотеки java.util.concurrent.
</li>
<li>
Классы, реализующие интерфейс Runnable должны реализовывать метод run() для выполнения задачи. Классы, реализующие интерфейс Callable должны реализовывать метод call() для выполнения задачи.
</li>
<li>
Метод Runnable.run() не возвращает никакого значения, его тип void, а метод Callable.call() может возвращать значение типа T. Интерфейс Callable является параметризированным Callable&lt;T&gt; и тип значения, которое будет возвращаться в методе call() задается этим параметром T.
</li>
<li>
Метод run() не может бросить проверяемое исключение, в то время как метод call() может бросить проверяемое исключение.
</li>
</ul>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2>Различия между CyclicBarrier и CountDownLatch ?</h2></font>
<p>
Хоть оба эти синхронизаторы позволяют нитям дожидаться друг друга, главное различие между ними в том, что вы не можете заново использовать CountDownLatch после того, как его счётчик достигнет нуля, но вы можете использовать CyclicBarrier снова, даже после того, как барьер сломается.
</p>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2>Что такое состояние гонки (race condition) ?</h2></font>
<p>
Состояние гонки - причина трудноуловимых багов. Как сказано в самом названии, состояние гонки возникает из-за гонки между несколькими нитями, если нить, которая должна исполнятся первой, проиграла гонку и исполняется вторая, поведение кода изменяется, из-за чего возникают недетерменированные баги. Это одни из сложнейших к отлавливанию и воспроизведению багов, из-за беспорядочной природы гонок между нитями. Пример состояния гонки - беспорядочное исполнение.
</p>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2>Как остановить нить ?</h2></font>
<p>
Java предоставляет богатые API для всего, но, по иронии судьбы, не предоставляет удобных способов остановки нити. В JDK 1.0 было несколько управляющих методов, например stop(), suspend() и resume(), которые были помечены как deprecated в будущих релизах из-за потенциальных угроз взаимной блокировки, с тех пор разработчики Java API не предприняли попыток представить стойкий, ните-безопасный и элегантный способ остановки нитей. Программисты в основном полагаются на факт того, что нить останавливается сама, как только заканчивает выполнять методы run() или call(). Для остановки вручную, программисты пользуются преимуществом volatile boolean переменной и проверяют её значение в каждой итерации, если в методе run() есть циклы, или прерывают нити методом interrupt() для внезапной отмены заданий.
</p>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2>Что происходит, когда в нити появляется исключение ?</h2></font>
<p>
Это один из хороших вопросов с подвохом. Простыми словами, если исключение не поймано - нить мерта, если установлен обработчик непойманных исключений, он получит колбек. Thread.UncaughtExceptionHandler – интерфейс, определённый как вложенный интерфейс для обработчиков, вызываемых, когда нить внезапно останавливается из-за непойманного исключения. Когда нить собирается остановится из-за непойманного исключения, JVM проверит её на наличие UncaughtExceptionHandler, используя Thread.getUncaughtExceptionHandler(), и вызовет у обработчика метод uncaughtException(), передав нить и исключение в виде аргументов.
</p>
</div>
</section>

<!-- 2  -->

<section>
<div class="content">
<font color="#ffa31a">	<h2>Что такое ThreadLocal переменная ?</h2></font>
<p>
ThreadLocal переменные - специальный вид переменных, доступных Java программисту. Так же, как для состояний есть переменная состояния, для нитей есть ThreadLocal переменные. Это неплохой способ достичь ните-безопасности для затратных-для-создания объектов, например вы можете сделать SimpleDateFormat ните-безопасным, используя ThreadLocal. Так как это затратный класс, его нежелательно использовать в локальной области, которая требует отдельных экземпляров на каждый вызов. Предоставляя каждой нити её собственную копию, вы убиваете двух зайцев. Во-первых, вы уменьшаете количество экземпляров затратных объектов, используя по новой фиксированное количество экземпляров, и во-вторых, вы достигаете ните-безопасности, без потерь синхронизации и неизменяемости. Ещё один хороший пример локальной переменной у нити - класс ThreadLocalRandom, который уменьшает количество экземпляров затратных-для-создания объектов Random в много-нитиевой среде.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2>Что такое FutureTask ? </h2></font>
<p>
FutureTask представляет собой отменяемое асинхронное вычисление в параллельном Java приложении. Этот класс предоставляет базовую реализацию Future, с методами для запуска и остановки вычисления, методами для запроса состояния вычисления и извлечения результатов. Результат может быть получен только когда вычисление завершено, метод получения будет заблокирован, если вычисление ещё не завершено. Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable. Так как FutureTask реализует Runnable, его можно передать Executor’у на выполнение.
</p>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2>Различие между interrupted и isInterrupted? </h2></font>
<p>
Основное различие между interrupted() и isInterrupted() в том, что первый сбрасывает статус прерывания, а второй нет. Механизм прерывания в Java реализован с использованием внутреннего флага, известного как статус прерывания. Прерывание нити вызовом Thread.interrupt() устанавливает этот флаг. Когда прерванная нить проверяет статус прерывания, вызывая статический метод Thread.interrupted(), статус прерывания сбрасывается. Нестатический метод isInterrupted(), который используется нитью для проверки статуса прерывания у другой нити, не изменяет флаг прерывания. Условно, любой метод, который завершается, выкинув InterruptedException сбрасывает при этом флаг прерывания. Однако, всегда существует возможность того, что флаг тут же снова установится, если другая нить вызовет interrupt().
</p>
</div>
</section>



<section>
<div class="content">
<font color="#ffa31a">	<h2>Почему методы wait и notify вызываются в синхронизированном блоке ?</h2></font>
<p>
Основная причина вызова wait и notify из синхронизированого блока или метода в том, что Java API обязательно требует этого. Если вы вызовете их не из синхронизированного блока, ваш код выбросит IllegalMonitorStateException. Более хитрая причина в том, чтобы избежать состояния гонки между вызовами wait и notify.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2>Что такое пул нитей ? </h2></font>
<p>
Создание нити затратно в плане времени и ресурсов. Если вы создаёте нить во время обработки запроса, это замедлит время отклика, также процесс может создать только ограниченное число нитей. Чтобы избежать этих проблем, во время запуска приложения создаётся пул нитей и нити повторно используются для обработки запросов. Этот пул нитей называется "thread pool", а нити в нём – рабочая нить. Начиная с Java 1.5 Java API предоставляет фреймворк Executor, который позволяет вам создавать различные пулы нитей, например single thread pool, который обрабатывает только одно задание за единицу времени, fixed thread pool, пул с фиксированным количеством нитей, и cached thread pool, расширяемый пул, подходящий для приложений с множеством недолгих заданий.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2>Различия между livelock и deadlock ?</h2></font>
<p>
Livelock схож с deadlock, только в livelock состояния нитей или вовлечённых процессов постоянно изменяются в зависимости друг от друга. Livelock - особый случай нехватки ресурсов. Реальный пример livelock'а - когда два человека встречаются в узком коридоре и каждый, пытаясь быть вежливым, отходит в сторону, и так они бесконечно двигаются из стороны в сторону.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2>Как проверить, удерживает ли нить lock ?</h2></font>
<p>
Я и не подозревал, что можно проверять, удерживает ли нить lock в данный момент, до тех пор, пока не столкнулся с этим вопросом в одном телефонном интервью. В java.lang.Thread есть метод holdsLock(), он возвращает true, тогда и только тогда, когда текущая нить удерживает монитор у определённого объекта.
</p>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2>Как получить дамп нити ?</h2></font>
<p>
Дамп нити позволяет узнать, чем нить занимается в данный момент. Существует несколько способов получения дампа нити, зависящих от операционной системы. В Windows вы можете использовать комбинацию ctrl + Break, в Linux - команду kill -3. Также вы можете воспользоваться утилитой jstack, она оперирует над id процесса, который вы можете узнать с помощью другой утилиты jps.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> Какой JVM параметр используется для контроля размера стека нити? </h2></font>
<p>
Это один из простых, -Xss параметер используется для контроля размера стека нити в Java.
</p>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Различия между synchronized и ReentrantLock ? </h2></font>
<p>
Были времена, когда единственный способ достижения взаимного исключения был через ключевое слово synchronized, но он имеет несколько недостатков, например нельзя расширить lock за пределами метода или блока кода и т.д. Java 5 решает эту проблему, предоставляя более утончённый контроль через интерфейс Lock. ReentrantLock – распространённая реализация Lock, которая предоставляет Lock с таким же базовым поведением и семантикой, как у неявного монитора, достигаемый использованием синхронизированных методов, но с расширенными возможностями.
</p>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Что такое Semaphore ? </h2></font>
<p>
Semaphore - это новый тип синхронизатора. Это семафор со счётчиком. Концептуально, семафор управляет набором разрешений. Каждый acquire() блокируется, если необходимо, до того, как разрешение доступно, затем получает его. Каждый release() добавляет разрешение, потенциально освобождая блокирующий получатель (acquirer). Однако при этом не используются фактические объекты разрешений; Semaphore просто хранит количество доступных и действует соответственно. Semaphore используется для защиты дорогих ресурсов, которые доступны в ограниченном количестве, например подключение к базе данных в пуле.
</p>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Что будет, если очередь пула нитей уже заполнена, а вы подадите задачу ? </h2></font>
<p>
Если очередь пула нитей заполнилась, то поданная задача будет "отклонена". Метод submit() у ThreadPoolExecutor'а выкидывает RejectedExecutionException, после чего вызывается RejectedExecutionHandler.
</p>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Различия между методами submit() и execute() у пула нитей ? </h2></font>
<p>
Оба метода являются способами подачи задачи в пул нитей, но между ними есть небольшая разница. Execute(Runnable command) определён в интерфейсе Executor и выполняет поданную задачу в будущем, но, что более важно, ничего не возвращает. С другой стороны submit() – перегруженный метод, он может принимать задачи типов Runnable и Callable и может возвращать объект Future, который можно использовать для отмены выполнения и/или ожидания результата вычислений. Этот метод определён в интерфейсе ExecutorService, который наследуется от интерфейса Executor, и каждый класс пула нитей, например ThreadPoolExecutor или ScheduledThreadPoolExecutor, наследует эти методы.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> Что такое блокирующий метод ? </h2></font>
<p>
Блокирующий метод - метод, который блокируется, до тех пор, пока не выполнится задание, например метод accept() у ServerSocket блокируется в ожидании подключения клиента. Здесь блокирование означает, что контроль не вернётся к вызывающему методу до тех пор, пока не выполнится задание. С другой стороны, существуют асинхронные или не блокирующиеся методы, которые завершаются до выполнения задачи.
</p>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Что такое ReadWriteLock ? </h2></font>
<p>
В целом, ReadWriteLock - это результат техники разбора lock'а для улучшения производительности параллельных приложений. Это интерфейс, который был добавлен в Java 5. Он оперирует парой связанных lock’ов, один для операций чтения, один для записи. Читающий lock может удерживаться одновременно несколькими читающими нитями, до тех пор пока не будет записывающих. Записывающий lock эксклюзивен. Если хотите, вы можете реализовать интерфейс с вашим набором правил, или вы можете использовать ReentrantReadWriteLock, который поддерживает максимум 65535 рекурсивных записывающих lock'ов и 65535 читающих lock'ов.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> Что такое double checked locking Синглтона ? </h2></font>
<p>
Это старый способ создания ните-безопасного синглтона, который пытается оптимизировать производительность, блокируясь только когда экземпляр синглтона создаётся впервые.
</p>
</div>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Что такое double checked locking Синглтона ? </h2></font>
<p>
Это старый способ создания ните-безопасного синглтона, который пытается оптимизировать производительность, блокируясь только когда экземпляр синглтона создаётся впервые.
</p>
</div>
</section>

<section>
<div class="content">
<font color="#ffa31a">	<h2> Что такое фреймворк Fork/Join ? </h2></font>
<p>
Фреймворк Fork/Join, представленный в JDK 7, - это мощная утилита, позволяющая разработчику пользоваться преимуществами нескольких процессоров у современных серверов. Он разработан для работы, которую можно рекурсивно разбить на маленькие частицы. Цель - использовать всю доступную вычислительную мощь, для увеличения производительности вашего приложения. Одного значительное преимущество этого фреймворка в том, что он использует work-stealing алгоритм (от work - работа и steal - красть). Рабочие нити, у которых закончились свои задания, могут "своровать" задания у других нитей, которые всё ещё заняты.
</p>
</div>
</section>


<section>
<!-- Полезные ссылки . -->
<div class="contentname">
<h4>Полезные ссылки:</h4>
</div>
<div class="content">
<ul>
<li> <a href="xxxxxx" target="_blank">xxxxx</a></li>

</ul></div>
</section>



<footer>
<!-- работа с куки -->
<script type="text/javascript">
	var x = document.cookie;
	if(x=='size=150'){
	document.body.style.fontSize='150%';
	}
	</script>
</footer>
</div>
</div></section></div></body><!-- Footer --></html>