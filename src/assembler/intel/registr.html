<!DOCTYPE html>
<html lang="ru"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<!-- author: Aleksandrovich Aleksey Borisovich -->
<title> Assembler Intel регистры x86-32- jf17.ru</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="https://jf17.ru/assets/main.css"> 
</head>
<body>
<!-- Heading -->
<section>
<div class="content">
<h1> <a href="https://jf17.ru/" >Главная</a></h1>
<h2> <a href="https://jf17.ru/assembler/index.html" >Assembler</a></h2>
<hr />
</div>
</section>
                                
<!-- Heading -->
<section>
<header>
<div class="content">
<font color="#ffa31a">	<h2> Assembler Intel регистры x86-32</h2></font>
<p>
8 регистров по 4 байта = 32 байта .
</p>
</div>
</header>
</section>


<section>
<div class="content">
<font color="#ffa31a">	<h2> Регистры данных (Регистры общего назначения)</h2></font>
<p>
<h3><span class="contenthead">AX(x16) или EAX(x32) или RAX(x64): Аккумулятор .</span></h3> 

Аккумулятор (регистр процессора) — регистр процессора, в котором сохраняются результаты выполнения арифметических и логических команд. <br>
Кроме регистра-аккумулятора результаты работы команд могут сохраняться в регистрах общего назначения или в оперативной памяти. <br><br>

Так, AH и AL каждый по одному байту, АХ - 2 байта (или word - слово), ЕАХ - 4 байта (или dword - двойное слово). <br>
Эти регистры используются для операций с данными, такими, как сравнение, математические операции или запись данных в память.<br> 
АН в DOS программах используется как определитель, какой сервис будет использоваться при вызове INT. <br>
</p>

<p>
<h3><span class="contenthead">O – The Open-Closed Principle</span></h3> 

Название: Принцип Открыт-Закрыт<br>

Определение: Программные сущности (классы, модули, функции и т.п.) должны быть открытыми для расширения, но закрытыми для модификации.<br>

Смысл: ограничить распространение изменений минимальным числом классов/модулей; позволить вести параллельную разработку путем фиксации интерфейсов классов и открытости реализаций.<br>

Краткое описание: закрытость модулей означает стабильность интерфейса и возможность использования классов/модулей клиентами. Открытость модулей означает возможность внесения изменений в поведении, путем изменения реализации или же путем переопределения поведения в наследниках. Борьба с изменениями заключается в ограничении количества изменений минимальным числом классов/модулей и не подразумевает возможность изменения поведения без перекомпиляции. На практике требуемая «гибкость» обеспечивается за счет наследования и сопоставления с образцом (pattern matching), в зависимости от того, какую операцию мы хотим упростить – добавление нового подтипа в иерархию наследования или добавление новой операции в семейство типов.<br>

Типичные примеры нарушения: размазывание информации об иерархии типов по всему приложению.<br>

Anti-OCP – Принцип фабрики-фабрик: Чрезмерная любовь к OCP ведет к переусложненным решениям с чрезмерным числом уровней абстракции. <br>
<br>
</p>

<p>
<h3><span class="contenthead">L – The Liskov Substitution Principle</span></h3> 

Название: Принцип замещения Барбары Лисков<br>

Определение: Должна быть возможность вместо базового типа подставить любой его подтип.<br>

Смысл: Реализуйте наследование подтипов правильно.<br>

Краткое описание: для корректной реализации отношения «ЯВЛЯЕТСЯ», наследник может ослаблять предусловие и усиливать постусловие (требовать меньше и гарантировать больше), при этом инварианты базового класса должны выполняться наследником. При нарушении этих правил подстановка экземпляров наследника в метод, принимающий базовый класс будет приводить к непредсказуемым последствиям.<br>

Типичные примеры нарушения: несогласованное поведение наследников, что приводит к необходимости приводить экземпляры базового класса к конкретным типам наследников.<br>

Anti-LSP – Принцип непонятного наследования. Данный анти-принцип проявляется либо в чрезмерном количестве наследования, либо в его полном отсутствии, в зависимости от опыта и взглядов местного главного архитектора <br>
<br>
</p>

<p>
<h3><span class="contenthead">I – Interface Segregation Principle</span></h3> 

Название: Принцип разделения интерфейсов<br>

Определение: клиенты не должны вынужденно зависеть от методов, которыми не пользуются.<br>

Смысл: класс должен предоставлять удобный интерфейс с точки зрения его разнообразных клиентов.<br>

Краткое описание: интерфейс класса должен быть цельным и согласованным не зависимо от числа клиентов. Несколько разных клиентов вполне могут использовать лишь подмножество методов класса, до тех пор, пока интерфейс класса будет оставаться согласованным. Проблемы появляются тогда, когда интерфейс класса начинает распухать или появляются разные методы с похожей семантикой лишь для того, чтобы ими было удобно пользоваться определенным клиентам.<br>

Типичные примеры нарушения: 1) класс или интерфейс содержит несколько методов со схожей семантикой, которые используются разными клиентами; 2) интерфейс класса слишком разнороден и содержит методы, отвечающие за слабосвязанные операции.<br>

Anti-ISP – Принцип тысячи интерфейсов. Интерфейсы классов разбиваются на слишком большое число составляющих, что делает их неудобными для использования всеми клиентами. <br>
<br>
</p>

<p>
<h3><span class="contenthead">D – The Dependency Inversion Principle</span></h3> 

Название: Принцип инверсии зависимостей<br>

Определение: Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те и другие должны зависеть от абстракций.<br>

Смысл: сделать ключевые и/или изменчивые зависимости класса явными.<br>

Краткое описание: слишком большое число зависимостей класса говорит о проблемах в дизайне. Возможно класс делает слишком многое, или же текущий класс не удачен, что приводит к необходимости дергания по одному методу у слишком большого числа зависимостей. Любой объектный дизайн представляет собой некоторый граф взаимодействующих объектов, при этом некоторые зависимости являются частью реализации и должны создаваться напрямую (композиция), а некоторые – передаваться ему извне (агрегация). Выделять зависимости особенно полезно, когда они являются изменчивыми (завязаны на окружения), или же представляют собой некоторую форму «стратегий».<br>

Типичные примеры нарушения: использование синглтонов, сервис-локаторов или же создание ключевых зависимостей класса по ходу дела в закрытых методах.<br>

Anti-DIP – Принцип инверсии сознания или DI-головного мозга. Интерфейсы выделяются для каждого класса и пачками передаются через конструкторы. Понять, где находится логика становится практически невозможно. <br>
<br><br>
</p>

</div>
</section>


<footer>
<!-- работа с куки -->
<script type="text/javascript">
	var x = document.cookie;
	if(x=='size=150'){
	document.body.style.fontSize='150%';
	}
	</script>
</footer>
</body><!-- Footer --></html>